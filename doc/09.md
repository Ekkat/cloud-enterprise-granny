## The Road to API-ness

### Prologue

True... it's been a while since the last chapter, but patience is one of these virtues that come with age. Hence let's hope that Granny doesn't mind too much and get it on with. In the [last chapter](/doc/08.md) we talked about proper user interface design, both from an outside-in but also inside-out approach. I still believe that the later is the enabler for a good user experience (UX). It's a classic principle of software development: proper layering, separation of concerns and componentization help to fine-tune individual aspects as one does not need to worry to break other things.

Judging by the feedback I received it seems that people people believe that the time applications need to cater for <span style="text-decoration: line-through;">browsers</span> user-agents that do not support <span style="text-decoration: line-through;">JavaScript</span> aeh [ECMAScript ](http://en.wikipedia.org/wiki/ECMAScript)is past us and rather a relict of the past. (_"Common, we live in the 21st century!"_)

I'd say it depends on the usage scenario and I believe there are still use cases where people will have to implement such fallbacks (e.g. in the public sector etc.) As always, it's a case-by-case situation and the additional efforts required to maintain a solid fallback mechanism for limited user-agents certainly need to considered and planned for. Yet, given that the whole idea behind this blog series is to talk about what it takes to implement an enterprise-ready solution I at least wanted to point out how it's done! Going forward we'll certainly focus on state-of-the-art techniques to maximize the user experience and only maintain a rudimentary fall-back solution (after all, _convenience goes a long way_, and users may be encouraged to update to a modern browser if they feel they are missing out!)

Having said all this, it's time to have a look at current trends in user interface technologies. Doing so, we quickly notice that there's a tendency to let the client do the heavy-lifting. Technologies such as HTML5, JavaScript (see above) and CSS3 have progressed tremendously over the last years and it's amazing to see what capable developers can build with these web standards! On the mobile side we see both web and native apps deliver great user experiences and containers like [Cordova](http://cordova.apache.org/) (aka PhoneGap) completely blurry the lines between web and native apps. In both scenarios the client handles the user interaction and only communicates with the server/backend via web services (in the broader sense of the word!) Typically, this is done using light-weight communication protocols and standards such as [REST](http://en.wikipedia.org/wiki/Representational_State_Transfer) (e.g. [JSON](http://en.wikipedia.org/wiki/JSON) via HTTP) or - as popular at SAP and Microsoft - [OData](http://en.wikipedia.org/wiki/OData). Consequently, the server is responsible of providing an [API](http://en.wikipedia.org/wiki/API) that can be used by clients.

### _There's an API for that!_

I truly believe that in the context of cloud computing and the [Internet of Things](http://en.wikipedia.org/wiki/Internet_of_Things) (IoT) the famous slogan "_[There's an app for that!](https://www.youtube.com/watch?v=EhkxDIr0y2U)_" ([copyright by Apple Inc.](https://www.apple.com/legal/intellectual-property/trademark/appletmlist.html)) will change into "_There's an API for that!_" - APIs are really the foundation of the magic of today's inter-connected world.

![Growth in Web APIs since 2005 - Source: ProgrammableWeb](09_programmable_web_growth_in_web_apis.jpg)

Growth in Web APIs Since 2005 - Source: [ProgrammableWeb](http://www.slideshare.net/programmableweb/web-api-growthsince2005)

Given the importance I opted for giving this topic some extra room and actually write a mini series about APIs... yet before we dig deeper I'd like to point out that the term API does not necessarily indicate that the exposed services/functionality is consumed from the outside. In fact, I strongly promote of clearly establishing an internal API comprising the business functionality of any application. Software is never finished! As such, as applications grow over time it clearly helps to have defined an internal API layer that is used between the individual components or modules across the application. Exposing this set of services (or parts) of it in such a way that external clients can consume them is a completely different story - and one that comes with its own challenges!

I already wrote extensively about Enterprise APIs, why they matter, their primary principles and how-to develop them in my respective blog post series called '**The Rise of Enterprise APIs**':

*   [The Rise of Enterprise APIs - Part I](http://scn.sap.com/community/cloud/blog/2012/06/05/the-raise-of-enterprise-apis)
*   [The Rise of Enterprise APIs - Part II](http://scn.sap.com/community/developer-center/cloud-platform/blog/2012/08/02/the-rise-of-enterprise-apis--part-ii)
*   [The Rise of Enterprise APIs - Part III](http://scn.sap.com/community/developer-center/cloud-platform/blog/2012/08/03/the-rise-of-enterprise-apis--part-iii)

As I hate to repeat myself I just refer you to the respective posts and only briefly point out things I deem important to make a point. From an implementation perspective Granny's Addressbook uses the same building blocks as the sample application I developed for [part 3](/community/developer-center/cloud-platform/blog/2012/08/03/the-rise-of-enterprise-apis--part-iii) of the series: [Apache CXF](http://cxf.apache.org/) (as a great implementation of the [JAX-RS standard](http://en.wikipedia.org/wiki/Java_API_for_RESTful_Web_Services), [Spring](http://projects.spring.io/spring-framework/), etc.

### API = A set of self-contained services

The most important aspect of a business service that shall be included within an API is that it needs to be self-contained. For the client/consumers it has to act as a black box and ultimately a client would not need to know anything about the internal workings of the service. Consequently, the service may not take anything for granted (e.g. that the incoming data is in proper format or that it has been validated for type-safety or plausibility). As such, the service needs to properly check any incoming data for validity and properly report back any issues there may be. Same applies for security aspects etc. All of these aspects need to be ensured regardless of whether it was an internal or an external client consuming the service. That's the reason why I usually promote separating the underlying service from the actual API endpoint (which is protocol and format specific!)

This mindset is reflected in the architecture of the Granny's Addressbook application. The [com.sap.hana.cloud.samples.granny.srv](https://github.com/SAP/cloud-enterprise-granny/tree/master/src/main/java/com/sap/hana/cloud/samples/granny/srv) package contains the actual service implementations, which are just regular Java classes. They use the standard data model objects of the application and declare to throw a dedicated [ServiceException](https://github.com/SAP/cloud-enterprise-granny/blob/master/src/main/java/com/sap/hana/cloud/samples/granny/srv/ServiceException.java). The RESTful API however is located in a different package called: [com.sap.hana.cloud.samples.granny.api](https://github.com/SAP/cloud-enterprise-granny/blob/master/src/main/java/com/sap/hana/cloud/samples/granny/api/). If you have a closer look at the so-called [Facades](http://en.wikipedia.org/wiki/Facade_pattern) within this package you will see that they contain certain meta information (annotations) that are specific to RESTful service communication (and part of the JAX-RS API.) Same is true for the `Response` objects returned by the individual service methods. 

**To be continued...**